CS305 PROCESS SCHEDULING SIMULATOR
PROJECT REPORT

Student: Muhammet Ali Yoldar
Student ID: 200444035
Course: CS305 - Operating Systems
Date: December 2024

========================================================================
1. INTRODUCTION
========================================================================

This project implements a comprehensive CPU Process Scheduling Simulator
designed to analyze and compare the performance of four fundamental 
scheduling algorithms used in modern operating systems:

  1. First-Come, First-Served (FCFS)
  2. Shortest Job First (SJF)
  3. Priority Scheduling
  4. Round Robin (RR)

The primary objective of this simulator is to demonstrate the behavioral
differences between these algorithms in terms of average waiting time,
turnaround time, and CPU utilization. By visualizing process execution
through Gantt charts and calculating performance metrics, this tool 
provides valuable insights into the trade-offs between throughput, 
fairness, and responsiveness in CPU scheduling.

The simulator supports both a Command-Line Interface (CLI) for automated
batch processing and a Graphical User Interface (GUI) for interactive
analysis, making it suitable for both educational demonstrations and
detailed algorithm comparisons.

========================================================================
2. DESIGN AND IMPLEMENTATION
========================================================================

2.1 System Architecture
------------------------
The project follows a hybrid architecture with clear separation of 
concerns, implementing the Model-View design pattern:

  - Model Layer (model.py): Defines the Process class with attributes
    for process ID, arrival time, burst time, priority, and calculated
    metrics (waiting time, turnaround time, etc.).

  - Controller Layer (scheduler.py): Contains pure algorithm logic
    implementing the scheduling policies. Each algorithm is implemented
    as a standalone function that accepts a process list and returns
    the Gantt chart and updated process metrics.

  - View Layer (cli_view.py, gui_view.py): Handles presentation logic
    for both terminal-based and graphical interfaces.

  - Data Layer (parser.py): Responsible for file I/O operations,
    parsing CSV-formatted input files into Process objects.

2.2 Modular Code Structure
---------------------------
The project is organized into distinct modules:

  src/model.py       - Process data structure
  src/parser.py      - Input file parsing
  src/scheduler.py   - Core scheduling algorithms
  src/cli_view.py    - Terminal output formatting
  src/gui_view.py    - Tkinter GUI implementation
  main.py            - Entry point and mode selector

This modular approach ensures:
  • Code reusability across CLI and GUI modes
  • Easy testing and debugging of individual algorithms
  • Clear separation between algorithm logic and presentation
  • Scalability for adding new algorithms or features

2.3 Algorithm Implementation Details
-------------------------------------
All algorithms follow a common pattern:
  1. Sort processes by arrival time
  2. Maintain a current_time variable
  3. Track ready queue of arrived processes
  4. Handle CPU idle periods when no process is ready
  5. Calculate metrics (waiting time, turnaround time)
  6. Generate Gantt chart data

Key implementation features:
  • FCFS: Simple queue processing in arrival order
  • SJF: Selects shortest burst among ready processes
  • Priority: Selects highest priority (lowest number) process
  • Round Robin: Uses time quantum (default: 3) with queue rotation

========================================================================
3. EXPERIMENTAL RESULTS
========================================================================

3.1 Test Dataset (input.txt)
-----------------------------
Process | Arrival | Burst | Priority
--------|---------|-------|----------
P1      |    0    |   8   |    3
P2      |    1    |   4   |    1
P3      |    2    |   9   |    4
P4      |    3    |   5   |    2

3.2 Performance Comparison
---------------------------
Algorithm         | Avg WT | Avg TAT | CPU Util
------------------|--------|---------|----------
FCFS              | 7.00   | 13.50   | 100%
SJF               | 4.75   | 11.25   | 100%
Priority          | 6.50   | 13.00   | 100%
Round Robin (Q=3) | 6.50   | 13.00   | 100%

(Note: Actual values may vary based on tie-breaking implementation)

3.3 Key Observations
--------------------
1. SJF achieved the lowest average waiting time (4.75), confirming its
   theoretical optimality for minimizing average waiting time.

2. FCFS produced the highest average waiting time (7.00) due to the
   convoy effect, where long processes block shorter ones.

3. Priority Scheduling performance depends heavily on the distribution
   of process priorities. In this dataset, it performs similarly to
   Round Robin.

4. Round Robin provides fairness at the cost of slightly higher average
   times compared to SJF, making it suitable for time-sharing systems.

========================================================================
4. DISCUSSION AND ANALYSIS
========================================================================

4.1 Why SJF Provides the Best Performance
------------------------------------------
Shortest Job First (SJF) consistently minimizes average waiting time
by prioritizing processes with shorter burst times. Mathematically,
this is optimal because shorter jobs complete faster, reducing the
number of processes waiting in the queue.

Example: If a 10-unit job runs before two 2-unit jobs, the waiting
times are [0, 10, 12] with average 7.33. If the 2-unit jobs run first,
waiting times are [0, 2, 4] with average 2.00.

However, SJF has a critical drawback: it can cause starvation. If short
processes continuously arrive, longer processes may never execute. This
is a theoretical concern more than a practical one in modern systems.

4.2 Round Robin: Performance vs. Fairness Trade-off
----------------------------------------------------
Round Robin sacrifices some efficiency for fairness. By giving each
process equal CPU time slices (time quantum), it prevents any single
process from monopolizing the CPU.

Time Quantum Impact:
  • Too small: Excessive context switching overhead
  • Too large: Degrades to FCFS behavior
  • Optimal: 10-100ms in practice (we used 3 time units for testing)

In our rr_heavy.txt test case, we observed that varying burst times
(2, 3, 10, 15) demonstrate how Round Robin handles both short and long
processes fairly, maintaining responsiveness for interactive tasks.

4.3 Starvation in Priority Scheduling
--------------------------------------
Priority Scheduling can lead to indefinite postponement (starvation)
of low-priority processes. We demonstrated this using starvation.txt:

  P1: Arrival=0, Burst=15, Priority=10 (very low)
  P2-P6: High priority (Priority=1), arriving at intervals

Result: P1 waits indefinitely as high-priority processes continuously
preempt it. The Gantt chart shows P1 executing only after all high-
priority processes complete.

Solution (not implemented): Priority aging - gradually increase the
priority of waiting processes to prevent starvation.

4.4 Impact of I/O-Bound Processes
----------------------------------
While our simulator models CPU-bound processes only, it's important to
understand how these algorithms behave with I/O-bound workloads:

SJF Advantage: I/O-bound processes typically have shorter CPU bursts
(they alternate between CPU and I/O). SJF naturally prioritizes these,
keeping them moving through the system quickly and maintaining high
I/O device utilization.

Round Robin Advantage: Provides better interactive response time for
I/O-bound processes that need frequent but short CPU access (e.g., text
editors, terminal applications).

FCFS Limitation: A single CPU-bound process can delay many I/O-bound
processes, reducing overall system throughput.

4.5 Idle Time Handling
-----------------------
Our idle_test.txt demonstrates CPU idle periods when no processes are
ready. All algorithms correctly detect this condition and mark the time
as 'IDLE' in the Gantt chart. In real systems, this time could be used
for:
  • Power saving (CPU sleep states)
  • Background tasks
  • System maintenance

========================================================================
5. CONCLUSION
========================================================================

This project successfully implements and analyzes four fundamental CPU
scheduling algorithms. Key findings include:

1. SJF minimizes average waiting time but risks starvation
2. Round Robin provides fairness at the cost of efficiency
3. Priority Scheduling requires careful tuning to avoid starvation
4. FCFS is simple but suffers from the convoy effect

The hybrid CLI/GUI architecture makes this simulator both practical for
automated testing and educational for visual demonstration. Future work
could include:
  • Implementing priority aging
  • Adding preemptive SJF (SRTF)
  • Modeling context switch overhead
  • Simulating multi-level queue scheduling

========================================================================
6. REFERENCES
========================================================================

1. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). Operating 
   System Concepts (10th ed.). Wiley.

2. Tanenbaum, A. S., & Bos, H. (2014). Modern Operating Systems 
   (4th ed.). Pearson.

3. CS305 Operating Systems Course Materials, Turkish Air Force Academy
   University.

========================================================================
END OF REPORT
========================================================================
