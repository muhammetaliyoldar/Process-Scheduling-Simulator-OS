CS305 OPERATING SYSTEMS - PROJECT REPORT
Process Scheduling Simulator: A Hybrid CLI/GUI Implementation

Student: Muhammet Ali Yoldar
Student ID: 200444035
Course: CS305 - Operating Systems
Institution: Türk Hava Kurumu University
Date: December 2024

=========================================================================

1. INTRODUCTION
=========================================================================

1.1 Project Objective

This project implements a comprehensive process scheduling simulator designed
to analyze and compare four fundamental CPU scheduling algorithms: First-Come
First-Served (FCFS), Shortest Job First (SJF), Priority Scheduling, and 
Round Robin (RR). The primary objective is to provide both theoretical 
understanding and practical visualization of how different scheduling 
algorithms impact system performance metrics such as waiting time, turnaround
time, and CPU utilization.

1.2 Project Scope

The simulator encompasses both educational and practical aspects of operating
system design:

- Theoretical Foundation: Implementation of classical scheduling algorithms
  with adherence to established operating system principles.

- Practical Application: Dual-interface architecture enabling both automated
  batch processing (CLI) and interactive visualization (GUI).

- Engineering Excellence: Integration of production-grade features including
  comprehensive logging, automated reporting, and intelligent performance
  analysis.

- Extensibility: Modular design allowing easy addition of new algorithms or
  metrics without modifying core architecture.

1.3 Significance

Understanding process scheduling is fundamental to operating system design
and performance optimization. This simulator serves as both an educational
tool for students and a practical utility for analyzing scheduling behavior
under various workload conditions. The inclusion of smart analysis capabilities
enables users to identify optimal algorithms for specific workload patterns,
bridging the gap between theoretical knowledge and practical decision-making.

=========================================================================

2. DESIGN & ARCHITECTURE
=========================================================================

2.1 Modular Design Philosophy

The project employs a clean Model-View-Controller (MVC) architectural pattern,
ensuring separation of concerns and maintainability:

MODEL (src/model.py):
- Process data structure with attributes: ID, arrival time, burst time,
  priority, and computed metrics (finish time, turnaround time, waiting time)
- Encapsulates process state and provides clean interface for schedulers

VIEW (src/cli_view.py, src/gui_view.py):
- CLI View: Terminal-based output with ASCII Gantt charts and formatted tables
- GUI View: Tkinter-based graphical interface with color-coded visualizations
- Both views consume identical data structures, enabling interface consistency

CONTROLLER (src/scheduler.py, main.py):
- Scheduler algorithms implement core scheduling logic
- Main controller orchestrates mode selection and data flow
- Parser module handles input/output operations

This separation enables:
- Independent development and testing of components
- Easy addition of new algorithms or views
- Improved code maintainability and readability

2.2 Feature: Hybrid Interface Architecture

One of the project's key innovations is the dual-interface design:

CLI MODE (Automation & Batch Processing):
- Ideal for: Automated testing, scripting, performance benchmarking
- Capabilities:
  * Headless operation for server environments
  * Scriptable execution for automated analysis
  * Command-line argument support for parameter variation
  * Batch processing of multiple test cases
  * Integration with external analysis tools via CSV export

GUI MODE (Interactive Visualization):
- Ideal for: Educational purposes, real-time analysis, presentation
- Capabilities:
  * Visual Gantt chart rendering with color coding
  * Interactive algorithm selection with active state feedback
  * Real-time metric calculation and display
  * File browser for easy dataset selection
  * Export functionality with progress indication

The hybrid design ensures maximum utility across different use cases while
maintaining code reusability through shared core components.

2.3 Feature: Data Persistence & CSV Export

The simulator implements automated result persistence through CSV export:

IMPLEMENTATION:
- Append-mode CSV writing preserves historical data across runs
- Timestamp tracking enables temporal analysis
- Priority metadata inclusion ensures complete data capture
- UTF-8 encoding guarantees universal compatibility

BENEFITS:
- Historical Tracking: Compare algorithm performance across different datasets
- External Analysis: Import data into spreadsheet or statistical tools
- Report Generation: Automated documentation for academic submissions
- Debugging: Verify algorithm correctness through data inspection

CSV FORMAT:
Timestamp,Algorithm,Process_ID,Arrival,Burst,Priority,Finish,Turnaround,Waiting
2025-12-19 18:22:53,FCFS,P1,0,8,3,8,8,0

This structured format enables easy parsing and analysis in tools such as
Excel, Python pandas, R, or database systems.

2.4 Feature: System Logging & Traceability

Production-grade logging system ensures complete execution traceability:

LOGGING ARCHITECTURE:
- Python's standard logging module with INFO level
- Timestamped entries with operation context
- Automatic log rotation prevents unbounded growth
- Structured format: %(asctime)s - %(levelname)s - %(message)s

LOGGED EVENTS:
1. Application lifecycle (startup, mode selection)
2. File I/O operations (parsing, success/failure)
3. Algorithm execution phases (start, completion, metrics)
4. Export operations (CSV generation, status)
5. Error conditions (file not found, invalid input)

BENEFITS:
- Debugging: Trace execution flow for error diagnosis
- Auditing: Complete record of simulator usage
- Performance Analysis: Identify bottlenecks through timing data
- User Support: Reproduce and diagnose user-reported issues

EXAMPLE LOG ENTRY:
2025-12-19 18:02:36 - INFO - Algorithm SJF execution completed - Avg WT: 7.75

2.5 Feature: Smart Analysis Engine

The simulator includes an intelligent recommendation system that automatically
identifies the optimal algorithm for given workload:

ANALYSIS METHODOLOGY:
1. Execute all four algorithms on identical process set
2. Calculate Average Waiting Time (primary metric) for each
3. Compare results and identify minimum waiting time
4. Present recommendation with visual emphasis

IMPLEMENTATION:
- Results stored in dictionary mapping algorithm name to (processes, avg_wt)
- Comparison using Python's min() function with custom key
- Visual presentation with ASCII star borders and emphasis

EXAMPLE OUTPUT:
⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
*** WINNER ALGORITHM: SJF ***
    Most efficient for this workload!
    Lowest Average Waiting Time: 7.75 time units
⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

SIGNIFICANCE:
- Educational: Demonstrates practical impact of algorithm selection
- Decision Support: Guides optimal algorithm choice for specific workloads
- Validation: Confirms theoretical predictions with empirical results

2.6 Algorithm Implementations

All four algorithms are implemented following classical definitions:

FCFS (First-Come First-Served):
- Non-preemptive
- Processes served in strict arrival order
- Simple implementation, O(n) complexity
- Prone to convoy effect with large burst times

SJF (Shortest Job First):
- Non-preemptive
- Selects process with minimum burst time from ready queue
- O(n²) complexity due to sorting operations
- Minimizes average waiting time (provably optimal)

Priority Scheduling:
- Non-preemptive
- Selects highest priority (lowest priority number) from ready queue
- O(n²) complexity
- Can cause starvation of low-priority processes

Round Robin:
- Preemptive
- Time quantum-based scheduling
- O(n) complexity
- Configurable via CLI argument or GUI input
- Suitable for time-shared systems

COMMON FEATURES:
- Proper handling of idle periods (IDLE markers in Gantt chart)
- Tie-breaking using FCFS rule (earliest arrival time)
- Calculation of finish time, turnaround time, waiting time
- Deep copy of process list to preserve original data

=========================================================================

3. RESULTS & ANALYSIS
=========================================================================

3.1 Test Dataset

Standard test case (processes.txt):
Process ID | Arrival Time | Burst Time | Priority
-----------|--------------|------------|----------
P1         | 0            | 8          | 3
P2         | 1            | 4          | 1
P3         | 2            | 9          | 4
P4         | 3            | 5          | 2

3.2 Performance Metrics

Algorithm    | Avg Waiting Time | Avg Turnaround Time | CPU Util
-------------|------------------|---------------------|----------
FCFS         | 8.75             | 15.25               | 100.00%
SJF          | 7.75             | 14.25               | 100.00%
Priority     | 7.75             | 14.25               | 100.00%
Round Robin  | 13.50            | 20.00               | 100.00%
(TQ=3)

3.3 Analysis of Results

OBSERVATION 1: SJF and Priority achieve identical performance
- Both algorithms select P2 (shortest/highest priority) after P1
- Both execute P4 before P3
- Identical execution order: P1 → P2 → P4 → P3
- This demonstrates that optimal scheduling depends on both algorithm
  choice and workload characteristics

OBSERVATION 2: Round Robin shows higher waiting time
- Preemptive nature causes context switching
- Processes must wait through multiple quantum cycles
- Time Quantum = 3 is suboptimal for this workload
- Demonstrates trade-off between fairness and efficiency

OBSERVATION 3: All algorithms achieve 100% CPU utilization
- No idle periods in test dataset
- All processes arrive within first 3 time units
- CPU continuously busy from T=0 to completion

3.4 Smart Analysis Recommendation

The smart analysis engine correctly identifies SJF (or Priority) as the
winner algorithm for this workload with Average Waiting Time of 7.75 time
units. This validates the theoretical prediction that SJF minimizes average
waiting time when all processes are CPU-bound and arrival times are known.

=========================================================================

4. DISCUSSION
=========================================================================

4.1 Why SJF Achieves Optimal Performance

SJF (Shortest Job First) achieves the lowest average waiting time due to
fundamental mathematical properties:

THEORETICAL BASIS:
- Minimizing average waiting time is equivalent to minimizing the sum of
  waiting times across all processes
- Executing shorter jobs first reduces the cumulative waiting time
- Mathematical proof: SJF is provably optimal for minimizing average
  waiting time in non-preemptive scheduling

PRACTICAL DEMONSTRATION:
In our test case:
- P2 (burst=4) executes before P3 (burst=9)
- This reduces P2's waiting time without significantly increasing P3's
- The cumulative effect produces minimum average waiting time

LIMITATIONS:
- Requires knowledge of future burst times (not realistic in practice)
- Can cause starvation of long processes
- Estimation-based variants (like Shortest Remaining Time) used in real systems

4.2 Impact of Time Quantum in Round Robin

The Time Quantum parameter critically affects Round Robin performance:

EXPERIMENTAL VALIDATION:
The CLI argument feature enables testing various Time Quantum values:
- python main.py data/processes.txt 1  (very small quantum)
- python main.py data/processes.txt 3  (default)
- python main.py data/processes.txt 10 (large quantum)

OBSERVATIONS:
Small Time Quantum (TQ = 1-2):
- More context switches
- Better response time
- Higher overhead
- Approaches Shortest Remaining Time First

Large Time Quantum (TQ >> burst times):
- Fewer context switches
- Approaches FCFS behavior
- Reduced fairness
- Better throughput

Optimal Time Quantum:
- Typically 10-100 milliseconds in real systems
- Balance between response time and overhead
- Workload-dependent optimization

Our implementation's CLI argument feature enables empirical exploration of
this trade-off without code modification.

4.3 Starvation Analysis

Priority Scheduling demonstrates the starvation problem:

MECHANISM:
- Low-priority processes wait indefinitely
- High-priority processes continuously arrive
- Ready queue never becomes favorable for low-priority processes

DEMONSTRATION (starvation.txt):
- Contains low-priority processes arriving early
- High-priority processes arrive continuously
- Low-priority processes experience extreme waiting times

SOLUTIONS (Not Implemented):
- Priority Aging: Gradually increase priority of waiting processes
- Time limits: Maximum waiting time threshold
- Multi-level feedback queues: Dynamic priority adjustment

Our implementation deliberately excludes aging to clearly demonstrate the
starvation phenomenon for educational purposes.

4.4 Impact of I/O-Bound Processes

CURRENT IMPLEMENTATION:
- All algorithms assume pure CPU-bound processes
- No I/O burst modeling
- Continuous execution until completion

THEORETICAL CONSIDERATIONS:
If I/O-bound processes were included:

CPU-Bound Process:
- Long CPU bursts
- Minimal I/O waiting
- Benefits from throughput-oriented scheduling

I/O-Bound Process:
- Short CPU bursts
- Frequent I/O operations
- Benefits from response-time-oriented scheduling

IMPACT ON ALGORITHMS:
FCFS: Poor performance with mixed workloads (convoy effect)
SJF: Favors I/O-bound processes (shorter CPU bursts)
Priority: Can prioritize interactive (I/O-bound) processes
Round Robin: Better fairness for mixed workloads

FUTURE ENHANCEMENT:
Adding I/O burst modeling would require:
- Extended process model with I/O burst times
- I/O queue management
- Device scheduling simulation
- More complex state transitions (running, waiting, ready)

=========================================================================

5. CONCLUSION
=========================================================================

5.1 Project Success

This project successfully demonstrates:

TECHNICAL ACHIEVEMENTS:
✓ Correct implementation of four classical scheduling algorithms
✓ Dual-interface architecture (CLI + GUI)
✓ Advanced features (logging, CSV export, smart analysis)
✓ Comprehensive testing with multiple datasets
✓ Zero external dependencies (pure Python standard library)

EDUCATIONAL OUTCOMES:
✓ Deep understanding of scheduling algorithm behavior
✓ Practical visualization of theoretical concepts
✓ Empirical validation of textbook predictions
✓ Experience with production-grade software engineering

ENGINEERING EXCELLENCE:
✓ Clean, modular architecture (MVC pattern)
✓ Comprehensive documentation and comments
✓ Industry-standard logging practices
✓ User-friendly interface design
✓ Automated testing and validation

5.2 Engineering Best Practices

The project demonstrates several industry-standard practices:

1. SEPARATION OF CONCERNS
   - Model, View, Controller clearly separated
   - Each module has single, well-defined responsibility
   - Enables independent testing and maintenance

2. DRY PRINCIPLE (Don't Repeat Yourself)
   - Common functionality extracted to shared modules
   - Both CLI and GUI reuse core algorithm implementations
   - CSV export and logging centralized

3. PRODUCTION LOGGING
   - Comprehensive event tracking
   - Timestamped entries for debugging
   - Appropriate log levels (INFO, ERROR)

4. DATA PERSISTENCE
   - Append-mode CSV ensures historical tracking
   - Structured format enables external analysis
   - UTF-8 encoding for universal compatibility

5. USER EXPERIENCE
   - Progress feedback during operations
   - Visual state indicators (active buttons)
   - Clear error messages
   - Multiple interface options for different use cases

5.3 Insights Gained

ALGORITHM BEHAVIOR:
- SJF provably minimizes average waiting time but requires future knowledge
- Round Robin provides fairness at the cost of efficiency
- Priority scheduling can cause starvation without aging mechanism
- FCFS simplicity comes with convoy effect vulnerability

IMPLEMENTATION CHALLENGES:
- Handling edge cases (idle periods, simultaneous arrivals)
- Maintaining process state across algorithm executions
- Balancing code complexity with feature richness
- Creating intuitive user interfaces

PRACTICAL APPLICATIONS:
- Smart analysis enables data-driven algorithm selection
- CLI automation supports large-scale testing
- CSV export enables integration with statistical tools
- Logging supports production deployment and debugging

5.4 Future Enhancements

Potential extensions for future work:

1. Additional Algorithms:
   - Shortest Remaining Time First (SRTF)
   - Multi-level Feedback Queue (MLFQ)
   - Lottery Scheduling
   - Completely Fair Scheduler (CFS)

2. Advanced Features:
   - I/O burst modeling
   - Multi-processor scheduling
   - Priority aging implementation
   - Real-time scheduling constraints

3. Analysis Tools:
   - Statistical analysis (standard deviation, confidence intervals)
   - Performance prediction models
   - Workload characterization
   - Automated test case generation

4. Visualization:
   - Timeline animations
   - Comparative Gantt charts
   - Performance metric graphs
   - Interactive parameter tuning

5.5 Final Remarks

This project represents a comprehensive exploration of process scheduling
algorithms, combining theoretical foundations with practical implementation
and engineering excellence. The inclusion of production-grade features such
as logging, data persistence, and intelligent analysis demonstrates the
application of software engineering best practices to an academic project.

The dual-interface architecture ensures utility across multiple use cases,
from educational demonstrations to automated performance analysis. The smart
recommendation engine bridges the gap between theoretical knowledge and
practical decision-making, enabling users to make data-driven choices about
algorithm selection.

Most importantly, the project succeeds in its primary educational objective:
providing a clear, interactive, and comprehensive tool for understanding how
different scheduling algorithms impact system performance. The combination
of visualization, automation, and analysis creates a learning environment
that enhances theoretical understanding through practical experimentation.

=========================================================================
END OF REPORT
=========================================================================
